@! This file is Copyright of the author, (c) Viktor Bodrogi, Jul 2016.
@p maximum_input_line_length = infinity

@t title smalltitlefont centre "M4 Library"

@B@<M4 macro library@>

These are the macros for generating m4.
Doc: <a href="https://www.gnu.org/software/m4/manual/m4.html">M4 info manual</a>.

@C
These are composite helper macro definitions from the documentation.
@$@<M4 library@>@{@#D # M4 Library
@#Mdivert(`-1')
@<Define m4_reverse@>
@<Define m4_cond@>
@<Define m4_join@>
@<Define m4_quote@>
@<Define m4_argn@>
@<Define m4_forloop@>
@<Define m4_foreach@>
@<Define m4_stack_foreach@>
@<Define m4_define_blind@>
@<Define m4_curry@>
@<Define m4_rename@>
@<Define m4_casechange@>
@<Define m4_fatal_error@>
@<Define m4_exch@>
@<Define m4_forloop2@>
@<Define m4_forloop3@>
@#Mdivert`'@#D@}

@C@<Prefix and helpers@>

Prefix @{m4_@}:
@$@#M@Z@M@{m4_@}

Default left and right quotes:
@$@#L@Z@M@{`@}
@$@#R@Z@M@{'@}

Delete New Line, @{m4_dnl@}:
@$@#D@Z@M@{@#Mdnl@}

@C@<Macro definitions@>

@D@<define@>
@$@<m4_define@>@(@2@)@Z@M@{@#Mdefine(@1,@2)@}
@$@<m4_define'@>@(@2@)@Z@M@{@#Mdefine(`@1',`@2')@}
@$@<m4_define''@>@(@2@)@Z@M@{@#Mdefine(``@1'',``@2'')@}

@E
This quotes and puts @{m4_dnl@} to the end of line:
@$@<m4_def@>@(@2@)@Z@M@{@#Mdefine(`@1',`@2')@#D@}

@E
The number of actual arguments in a macro call is denoted by @{$#@} in the expansion text.

Composite: @{nargs (@^D(133))@}
@$@<m4_nargs@>@Z@M@{$#@}
The notation @{$*@} can be used in the expansion text to denote all the actual arguments, unquoted, with commas in between.
@E
@$@<m4_args@>@Z@M@{$*@}
Often each argument should be quoted, and the notation @{$@@@} handles that. It is just like @{$*@}, except that it quotes each argument.
@$@<m4_args'@>@Z@M@{$@@@}

@D@<undefine@>
A macro definition can be removed with @{undefine@}:

Builtin: @{undefine (name@^D(133))@}
@$@<m4_undefine@>@(@1@)@Z@M@{@#Mundefine(@1)@#D@}

@D@<defn@>
Expands to the quoted definition of each name:

Builtin: @{defn (name@^D(133)).@}
@$@<m4_defn@>@(@1@)@Z@M@{@#Mdefn(@1)@#D@}

@D@<pushdef@>
It is possible to redefine a macro temporarily, reverting to the previous definition at a later time.
This is done with the builtins @{pushdef@} and @{popdef@}:

Builtin: @{pushdef (name, [expansion])@}
@$@<m4_pushdef@>@(@1@)@Z@M@{@#Mpushdef(@1)@#D@}

@D@<popdef@>
Builtin: @{popdef (name@^D(133))@}
@$@<m4_popdef@>@(@1@)@Z@M@{@#Mpopdef(@1)@#D@}

@D@<indir@>
Any macro can be called indirectly with @{indir@}:

Builtin: @{indir (name, [args@^D(133)])@}
@$@<m4_indir@>@(@1@)@Z@M@{@#Mindir(@1)@#D@}

@D@<builtin@>
Builtin macros can be called indirectly with @{builtin@}:

Builtin: @{builtin (name, [args@^D(133)])@}
@$@<m4_builtin@>@(@1@)@Z@M@{@#Mbuiltin(@1)@#D@}

@C@<Conditionals and loops@>

@D@<ifdef@>
There are two different builtin conditionals in @{m4@}. The first is @{ifdef@}:

Builtin: ifdef (name, string-1, [string-2])
@$@<m4_ifdef@>@(@3@)@Z@M@{@#Mifdef(@1,@2,@3)@}
@$@<m4_ifdef'@>@(@3@)@Z@M@{@#Mifdef(`@1',`@2',`@3')@}

@D@<ifelse@>
The other conditional, @{ifelse@}, is much more powerful.
It can be used as a way to introduce a long comment,
as an if-else construct,
or as a multibranch, depending on the number of arguments supplied:

Builtin: @{ifelse (comment)@}
Builtin: @{ifelse (string-1, string-2, equal, [not-equal])@}
Builtin: @{ifelse (string-1, string-2, equal-1, string-3, string-4, equal-2, @^D(133), [not-equal])@}
@$@<m4_ifelse@>@(@1@)@Z@M@{@#Mifelse(@1)@}
@$@<m4_ifelse=@>@(@3@)@Z@M@{@#Mifelse(@1,@2,@3)@}
@!$@<m4_ifelse4@>@(@4@)@Z@M@{@#Mifelse(@1,@2,@3,@4)@}
@!$@<m4_ifelse6@>@(@6@)@Z@M@{@#Mifelse(@1,@2,@3,@4,@5,@6)@}
@!$@<m4_ifelse7@>@(@7@)@Z@M@{@#Mifelse(@1,@2,@3,@4,@5,@6,@7)@}

@D@<Recursion in m4@>
There is no direct support for loops in @{m4@}, but macros can be recursive. There is no limit on the number of recursion levels, other than those enforced by your hardware and operating system.
Loops can be programmed using recursion and the conditionals described previously.

@E@<shift@>
There is a builtin macro, @{shift@}, which can, among other things, be used for iterating through the actual arguments to a macro:

Builtin: @{shift (arg1, @^D(133))@}
@$@<m4_shift@>@(@1@)@Z@M@{@#Mshift(@1)@}

Takes any number of arguments, and expands to all its arguments except arg1, separated by commas, with each argument quoted.

@E@<reverse@>
Composite: @{reverse (@^D(133))@}
@$@<m4_reverse@>@(@1@)@Z@M@{@#Mreverse(@1)@}

Takes any number of arguments, and reverses their order.

@$@<Define m4_reverse@>@{@-
@#Mm4_define(`@#Mreverse', `@#Mifelse(`$#',`0',,`$#',`1',``$1'',`@#Mreverse(@#Mshift($@@)),`$1'')')@}

@E@<cond@>
Composite: @{cond (test-1, string-1, equal-1, [test-2])@}
@$@<m4_cond@>@(@1@)@Z@M@{@#Mcond(@1)@}

Similar to @{ifelse@}, where an equal comparison between the first two strings results in the third, otherwise the first three arguments are discarded and the process repeats. The difference is that each test-<n> is expanded only when it is encountered. This means that every third argument to cond is normally given one more level of quoting than the corresponding argument to ifelse.

@$@<Define m4_cond@>@{@-
@#Mm4_define(`@#Mcond',`@#Mifelse(`$#',`1',`$1',
    `@#Mifelse($1, `$2', `$3',
        `$0(@#Mshift(@#Mshift(@#Mshift($@@))))')')')@}

@E@<join@>
Another common task that requires iteration is joining a list of arguments into a single string.

Composite: @{join ([separator])@}
@$@<m4_join@>@(@1@)@Z@M@{@#Mjoin(@1)@}
@E@<joinall@>
Composite: @{joinall ([separator])@}
@$@<m4_joinall@>@(@1@)@Z@M@{@#Mjoinall(@1)@}

Generate a single-quoted string, consisting of each arg separated by separator. While @{joinall@} always outputs a separator between arguments, @{join@} avoids the separator for an empty arg.

@$@<Define m4_join@>@{@-
# @#Mjoin(sep, args) - join each non-empty ARG into a single
# string, with each element separated by SEP
@#Mdefine(`@#Mjoin',
`@#Mifelse(`$#', `2', ``$2'',
  `@#Mifelse(`$2', `', `', ``$2'_')$0(`$1', @#Mshift(@#Mshift($@@)))')')
@#Mdefine(`_@#Mjoin',
`@#Mifelse(`$#$2', `2', `',
  `@#Mifelse(`$2', `', `', ``$1$2'')$0(`$1', @#Mshift(@#Mshift($@@)))')')
# @#Mjoinall(sep, args) - join each ARG, including empty ones,
# into a single string, with each element separated by SEP
@#Mdefine(`@#Mjoinall', ``$2'_$0(`$1', @#Mshift($@@))')
@#Mdefine(`_@#Mjoinall',
`@#Mifelse(`$#', `2', `', ``$1$3'$0(`$1', @#Mshift(shift($@@)))')')@}

@E@<quote@>
Sometimes, a recursive algorithm requires adding quotes to each element, or treating multiple arguments as a single element:

Composite: @{quote (@^D(133))@}
@$@<m4_quote@>@(@1@)@Z@M@{@#Mquote(@1)@}
@E@<dquote@>
Composite: @{dquote (@^D(133))@}
@$@<m4_dquote@>@(@1@)@Z@M@{@#Mdquote(@1)@}
@E@<dquote_elt@>
Composite: @{dquote_elt (@^D(133))@}
@$@<m4_dquote_elt@>@(@1@)@Z@M@{@#Mdquote_elt(@1)@}

Takes any number of arguments, and adds quoting. With @{quote@}, only one level of quoting is added, effectively removing whitespace after commas and turning multiple arguments into a single string. With @{dquote@}, two levels of quoting are added, one around each element, and one around the list. And with @{dquote_elt@}, two levels of quoting are added around each element.

@$@<Define m4_quote@>@{@-
# @#Mquote(args) - convert args to single-quoted string
@#Mdefine(`@#Mquote', `@#Mifelse(`$#', `0', `', ``$*'')')
# @#Mdquote(args) - convert args to quoted list of quoted strings
@#Mdefine(`@#Mdquote', ``$@@'')
# @#Mdquote_elt(args) - convert args to list of double-quoted strings
@#Mdefine(`@#Mdquote_elt', `@#Mifelse(`$#', `0', `', `$#', `1', ```$1''',
    ```$1'',$0(@#Mshift($@@))')')@}

@E@<argn@>
One more useful macro based on shift allows portably selecting an arbitrary argument (usually greater than the ninth argument), without relying on the GNU extension of multi-digit arguments (see Arguments).

Composite: @{argn (n, @^D(133))@}
@$@<m4_argn@>@(@1@)@Z@M@{@#Margn(@1)@}

Expands to argument n out of the remaining arguments. n must be a positive number. Usually invoked as @{argn(`n',$@@)@}.

It is implemented as:

@$@<Define m4_argn@>@{@-
@#Mdefine(`@#Margn', `@#Mifelse(`$1', 1, ``$2'',
  `@#Margn(decr(`$1'), @#Mshift(@#Mshift($@@)))')')@}

  
@D@<Iteration by counting@>

Here is an example of a loop macro that implements a simple for loop.

@E@<forloop@>
Composite: @{forloop (iterator, start, end, text)@}
@$@<m4_forloop@>@(@1@)@Z@M@{@#Mforloop(@1)@}

Takes the name in @{iterator@}, which must be a valid macro name, and successively assign it each integer value from @{start@} to @{end@}, inclusive. For each assignment to iterator, append text to the expansion of the @{forloop@}. @{text@} may refer to iterator. Any definition of iterator prior to this invocation is restored.

@$@<Define m4_forloop@>@{@-
# @#Mforloop(var, from, to, stmt) - simple version
@#Mdefine(`@#Mforloop', `@#Mpushdef(`$1', `$2')_@#Mforloop($@@)@#Mpopdef(`$1')')
@#Mdefine(`_@#Mforloop',
    `$4`'@#Mifelse($1, `$3', `', `@#Mdefine(`$1', @#Mincr($1))$0($@@)')')@}


@D@<Iteration by list contents@>

Here is an example of a loop macro that implements list iteration.

@E@<foreach@>
Composite: @{foreach (iterator, paren-list, text)@}
@$@<m4_foreach@>@(@1@)@Z@M@{@#Mforeach(@1)@}
@E@<foreachq@>
Composite: @{foreachq (iterator, quote-list, text)@}
@$@<m4_foreachq@>@(@1@)@Z@M@{@#Mforeachq(@1)@}

Takes the name in @{iterator@}, which must be a valid macro name, and successively assign it each value from @{paren-list@} or @{quote-list@}. In @{foreach@}, @{paren-list@} is a comma-separated list of elements contained in parentheses. In @{foreachq@}, @{quote-list@} is a comma-separated list of elements contained in a quoted string.
For each assignment to @{iterator@}, append text to the overall expansion. text may refer to iterator. Any definition of @{iterator@} prior to this invocation is restored.

@$@<Define m4_foreach@>@{@-
# @#Mforeach(x, (item_1, item_2, ..., item_n), stmt)
#   parenthesized list, simple version
@#Mdefine(`@#Mforeach', `@#Mpushdef(`$1')_@#Mforeach($@@)@#Mpopdef(`$1')')
@#Mdefine(`_@#Marg1', `$1')
@#Mdefine(`_@#Mforeach', `@#Mifelse(`$2', `()', `',
    `@#Mdefine(`$1', _@#Marg1$2)$3`'$0(`$1', (@#Mshift$2), `$3')')')
# @#Mforeachq(x, `item_1, item_2, ..., item_n', stmt)
#   quoted list, simple version
@#Mdefine(`@#Mforeachq', `@#Mpushdef(`$1')_@#Mforeachq($@@)@#Mpopdef(`$1')')
@#Mdefine(`_@#Marg1', `$1')
@#Mdefine(`_@#Mforeachq', `@#Mifelse(quote($2), `', `',
    `@#Mdefine(`$1', `_@#Marg1($2)')$3`'$0(`$1', `@#Mshift($2)', `$3')')')@}

@D@<Working with definition stacks@>

Thanks to @{pushdef@}, manipulation of a stack is an intrinsic operation in m4. Normally, only the topmost definition in a stack is important, but sometimes, it is desirable to manipulate the entire definition stack.

@E@<stack_foreach@>
Composite: @{stack_foreach (macro, action)@}
@$@<m4_stack_foreach@>@(@1@)@Z@M@{@#Mstack_foreach(@1)@}
@E@<stack_foreach_lifo@>
Composite: @{stack_foreach_lifo (macro, action)@}
@$@<m4_stack_foreach_lifo@>@(@1@)@Z@M@{@#Mstack_foreach_lifo(@1)@}

For each of the @{pushdef@} definitions associated with macro, invoke the macro action with a single argument of that definition. @{stack_foreach@} visits the oldest definition first, while @{stack_foreach_lifo@} visits the current definition first. action should not modify or dereference macro. There are a few special macros, such as @{defn@}, which cannot be used as the macro parameter.

@$@<Define m4_stack_foreach@>@{@-
# @#Mstack_foreach(macro, action)
# Invoke ACTION with a single argument of each definition
# from the definition stack of MACRO, starting with the oldest.
@#Mdefine(`@#Mstack_foreach',
`_@#Mstack_reverse(`$1', `_@#Mtmp-$1')'@#D
`_@#Mstack_reverse(`_@#Mtmp-$1', `$1', `$2(@#Mdefn(`$1'))')')
# @#Mstack_foreach_lifo(macro, action)
# Invoke ACTION with a single argument of each definition
# from the definition stack of MACRO, starting with the newest.
@#Mdefine(`@#Mstack_foreach_lifo',
`_@#Mstack_reverse(`$1', `_@#Mtmp-$1', `$2(@#Mdefn(`$1'))')'@#D
`_@#Mstack_reverse(`_@#Mtmp-$1', `$1')')
@#Mdefine(`_@#Mstack_reverse',
`@#Mifdef(`$1', `@#Mpushdef(`$2', @#Mdefn(`$1'))$3`'@#Mpopdef(`$1')$0($@@)')')@}

@D@<Building macros with macros@>

Since @{m4@} is a macro language, it is possible to write macros that can build other macros. First on the list is a way to automate the creation of blind macros.

@E@<define_blind@>
Composite: @{define_blind (name, [value])@}
@$@<m4_define_blind@>@(@1@)@Z@M@{@#Mdefine_blind(@1)@}

Defines name as a blind macro, such that name will expand to value only when given explicit arguments.
@{value@} should not be the result of @{defn@}. This macro is only recognized with parameters, and results in an empty string.

@$@<Define m4_define_blind@>@{@-
@#Mdefine(`@#Mdefine_blind', `@#Mifelse(`$#', `0', ``$0'',
`_@#M$0(`$1', `$2', `$'`#', `$'`0')')')
@#Mdefine(`_@#Mdefine_blind', `@#Mdefine(`$1',
`@#Mifelse(`$3', `0', ``$4'', `$2')')')@}

@E@<curry@>
Another interesting composition tactic is argument currying, or factoring a macro that takes multiple arguments for use in a context that provides exactly one argument.

Composite: @{curry (macro, @^D(133))@}
@$@<m4_curry@>@(@1@)@Z@M@{@#Mcurry(@1)@}

Expand to a macro call that takes exactly one argument, then appends that argument to the original arguments and invokes macro with the resulting list of arguments.

@$@<Define m4_curry@>@{@-
# @#Mcurry(macro, args)
# Expand to a macro call that takes one argument, then invoke
# macro(args, extra).
@#Mdefine(`@#Mcurry', `$1(@#Mshift($@@,)_@#M$0')
@#Mdefine(`_@#Mcurry', ``$1')')@}

@E@<rename@>
Putting the last few concepts together, it is possible to @{copy@} or @{rename@} an entire stack of macro definitions.

Composite: @{rename (source, dest)@}
@$@<m4_rename@>@(@1@)@Z@M@{@#Mrename(@1)@}
@E@<copy@>
Composite: @{copy (source, dest)@}
@$@<m4_copy@>@(@1@)@Z@M@{@#Mcopy(@1)@}

Ensure that @{dest@} is undefined, then define it to the same stack of definitions currently in source. @{copy@} leaves @{source@} unchanged, while @{rename@} undefines @{source@}. There are only a few macros, such as @{copy@} or @{defn@}, which cannot be copied via this macro.

@$@<Define m4_rename@>@{@-
@#Mdefine(`@#Mrename', `@#Mcopy($@@)@#Mundefine(`$1')')
@#Mdefine(`@#Mcopy', `@#Mifdef(`$2', `@#Merrprint(`$2 already defined
')@#Mm4exit(`1')', `@#Mstack_foreach(`$1', `@#Mcurry(`@#Mpushdef', `$2')')')')
@#Mpushdef(`a', `1')@#Mpushdef(`a', @#Mdefn(`@#Mdivnum'))@#Mpushdef(`a', `2')@}


@C@<Debug macros and input@>

@D@<dumpdef: Displaying macro definitions@>

If you want to see what a name expands into, you can use the builtin @{dumpdef@}:

Builtin: @{dumpdef ([names@^D(133)])@}
@$@<m4_dumpdef@>@(@1@)@Z@M@{@#Mdumpdef(@1)@}

Accepts any number of arguments. If called without any arguments, it displays the definitions of all known names, otherwise it displays the definitions of the names given. The output is printed to the current debug file (usually standard error), and is sorted by name. If an unknown name is encountered, a warning is printed.

@D@<Tracing macro calls@>

It is possible to trace macro calls and expansions through the builtins traceon and traceoff:

@E@<traceon@>
Builtin: @{traceon ([names@^D(133)])@}
@$@<m4_traceon@>@(@1@)@Z@M@{@#Mtraceon(@1)@}
@E@<traceoff@>
Builtin: @{traceoff ([names@^D(133)])@}
@$@<m4_traceoff@>@(@1@)@Z@M@{@#Mtraceoff(@1)@}

When called without any arguments, @{traceon@} and @{traceoff@} will turn tracing on and off, respectively, for all currently defined macros.

When called with arguments, only the macros listed in names are affected, whether or not they are currently defined.

@D@<debugmode: Controlling debugging output@>

Builtin: @{debugmode ([flags])@}

@$@<m4_debugmode@>@(@1@)@Z@M@{@#Mdebugmode(@1)@}

The argument flags should be a subset of the letters listed above. As special cases, if the argument starts with a @{+@}, the flags are added to the current debug flags, and if it starts with a @{-@}, they are removed. If no argument is present, all debugging flags are cleared (as if no @{-d@} was given), and with an empty argument the flags are reset to the default of @{aeq@}.

The @{-d@} option to @{m4@} (or @{--debug@}, see Invoking m4) controls the amount of details presented in three categories of output. Trace output is requested by traceon (see Trace), and each line is prefixed by @{m4trace:@} in relation to a macro invocation. Debug output tracks useful events not associated with a macro invocation, and each line is prefixed by @{m4debug:@}. Finally, @{dumpdef@} (see Dumpdef) output is affected, with no prefix added to the output lines.

The flags following the option can be one or more of the following:

@{a@}
In trace output, show the actual arguments that were collected before invoking the macro. This applies to all macro calls if the @{t@} flag is used, otherwise only the macros covered by calls of traceon. Arguments are subject to length truncation specified by the command line option @{--arglength@} (or @{-l@}).

@{c@}
In trace output, show several trace lines for each macro call. A line is shown when the macro is seen, but before the arguments are collected; a second line when the arguments have been collected and a third line after the call has completed.

@{e@}
In trace output, show the expansion of each macro call, if it is not void. This applies to all macro calls if the @{t@} flag is used, otherwise only the macros covered by calls of traceon. The expansion is subject to length truncation specified by the command line option @{--arglength@} (or @{-l@}).

@{f@}
In debug and trace output, include the name of the current input file in the output line.

@{i@}
In debug output, print a message each time the current input file is changed.

@{l@}
In debug and trace output, include the current input line number in the output line.

@{p@}
In debug output, print a message when a named file is found through the path search mechanism (see Search Path), giving the actual file name used.

@{q@}
In trace and dumpdef output, quote actual arguments and macro expansions in the display with the current quotes. This is useful in connection with the @{a@} and e flags above.

@{t@}
In trace output, trace all macro calls made in this invocation of m4, regardless of the settings of traceon.

@{x@}
In trace output, add a unique macro call id to each line of the trace output. This is useful in connection with the @{c@} flag above.

@{V@}
A shorthand for all of the above flags.

If no flags are specified with the @{-d@} option, the default is @{aeq@}. The examples throughout this manual assume the default flags.

There is a builtin macro @{debugmode@}, which allows on-the-fly control of the debugging output format:

@D@<debugfile: Saving debugging output@>

Debug and tracing output can be redirected to files using either the @{--debugfile@} option to m4 (see Invoking m4), or with the builtin macro @{debugfile@}:

Builtin: @{debugfile ([file])@}

@$@<m4_debugfile@>@(@1@)@Z@M@{@#Mdebugfile(@1)@}

Sends all further debug and trace output to file, opened in append mode. If file is the empty string, debug and trace output are discarded. If @{debugfile@} is called without any arguments, debug and trace output are sent to standard error. This does not affect warnings, error messages, or errprint output, which are always sent to standard error. If file cannot be opened, the current debug file is unchanged, and an error is issued.

@C@<Input control@>

@D@<dnl: Deleting whitespace in input@>

All characters, up to and including the next newline, are discarded without performing any macro expansion. A warning is issued if the end of the file is encountered without a newline.

Builtin: @{dnl@}
@$@<m4_dnl@>@Z@M@{@#Mdnl@}

It is often used in connection with @{define@}, to remove the newline that follows the call to @{define@}.

@D@<changequote: Changing the quote characters@>

The default quote delimiters can be changed with the builtin changequote:

Builtin: @{changequote ([start[,end])@}
@$@<m4_changequote@>@Z@M@{@#Mchangequote@}

This sets start as the new begin-quote delimiter and end as the new end-quote delimiter. If both arguments are missing, the default quotes (@{`@} and @{'@}) are used. If start is void, then quoting is disabled. Otherwise, if end is missing or void, the default end-quote delimiter (@{'@}) is used. The quote delimiters can be of any length.

@D@<changecom: Changing the comment delimiters@>

The default comment delimiters can be changed with the builtin macro @{changecom@}:

Builtin: @{changecom ([start[,end])@}
@$@<m4_changecom@>@Z@M@{@#Mchangecom@}

This sets start as the new begin-comment delimiter and end as the new end-comment delimiter. If both arguments are missing, or start is void, then comments are disabled. Otherwise, if end is missing or void, the default end-comment delimiter of newline is used. The comment delimiters can be of any length.

@D@<changeword: Changing the lexical structure of words@>

The macro @{changeword@} and all associated functionality is experimental. It is only available if the @{--enable-changeword@} option was given to configure, at GNU m4 installation time. The functionality will go away in the future, to be replaced by other new features that are more efficient at providing the same capabilities. Do not rely on it. Please direct your comments about it the same way you would do for bugs.

A file being processed by m4 is split into quoted strings, words (potential macro names) and simple tokens (any other single character). Initially a word is defined by the following regular expression:

@{[_a-zA-Z][_a-zA-Z0-9]*@}

Using @{changeword@}, you can change this regular expression:

Optional builtin: @{changeword (regex)@}
@$@<m4_changeword@>@(@1@)@Z@M@{@#Mchangeword(@1)@}

Changes the regular expression for recognizing macro names to be regex. If regex is empty, use @{[_a-zA-Z][_a-zA-Z0-9]*@}. regex must obey the constraint that every prefix of the desired final pattern is also accepted by the regular expression. If regex contains grouping parentheses, the macro invoked is the portion that matched the first group, rather than the entire matching string.

Because @{m4@} constructs its words a character at a time, there is a restriction on the regular expressions that may be passed to changeword. This is that if your regular expression accepts @{foo@}, it must also accept @{f@} and @{fo@}.

@{changeword@} has another function. If the regular expression supplied contains any grouped subexpressions, then text outside the first of these is discarded before symbol lookup. So:

@{ifdef(`changeword', `', `errprint(` skipping: no changeword support
')m4exit(`77')')dnl
ifdef(`__unix__', ,
      `errprint(` skipping: syscmd does not have unix semantics
')m4exit(`77')')dnl
changecom(`/*', `*/')dnl
define(`foo', `bar')dnl
changeword(`#\([_a-zA-Z0-9]*\)')
#esyscmd(`echo foo \#foo')
@}

@{m4@} now requires a @{#@} mark at the beginning of every macro invocation, so one can use m4 to preprocess plain text without losing various words like @{divert@}.

@D@<m4wrap: Saving text until end of input@>

Builtin: @{m4wrap (string, @^D(133))@}
@$@<m4_m4wrap@>@(@1@)@Z@M@{@#Mm4wrap(@1)@}

Stores string in a safe place, to be reread when end of input is reached. As a GNU extension, additional arguments are concatenated with a space to the string.

@C@<File inclusion@>

@D@<Including named files@>

There are two builtin macros in m4 for including files:

@E@<include@>
Builtin: @{include (file)@}
@$@<m4_include@>@(@1@)@Z@M@{@#Minclude(@1)@}
@E@<sinclude@>
Builtin: @{sinclude (file)@}
@$@<m4_sinclude@>@(@1@)@Z@M@{@#Msinclude(@1)@}

Both macros cause the file named file to be read by m4. When the end of the file is reached, input is resumed from the previous input file.

The expansion of @{include@} and @{sinclude@} is therefore the contents of file.

If file does not exist, is a directory, or cannot otherwise be read, the expansion is void, and @{include@} will fail with an error while @{sinclude@} is silent. The empty string counts as a file that does not exist.

@E@<Searching for include files@>

GNU m4 allows included files to be found in other directories than the current working directory.

If the @{--prepend-include@} or @{-B@} command-line option was provided (see Invoking m4), those directories are searched first, in reverse order that those options were listed on the command line. Then @{m4@} looks in the current working directory. Next comes the directories specified with the @{--include@} or @{-I@} option, in the order found on the command line.
Finally, if the @{M4PATH@} environment variable is set, it is expected to contain a colon-separated list of directories, which will be searched in order.

@$@<M4 include path env var@>@Z@M@{M4PATH@}

@C@<Diverting and undiverting output@>

@D@<divert: Diverting output@>
Output is diverted using divert:

Builtin: @{divert ([number = 0])@}
@$@<m4_divert@>@Z@M@{@#Mdivert@}

The current diversion is changed to number. If number is left out or empty, it is assumed to be zero. If number cannot be parsed, the diversion is unchanged.

When all the m4 input will have been processed, all existing diversions are automatically undiverted, in numerical order

Several calls of divert with the same argument do not overwrite the previous diverted text, but append to it. Diversions are printed after any wrapped text is expanded.

If output is diverted to a negative diversion, it is simply discarded. This can be used to suppress unwanted output. A common example of unwanted output is the trailing newlines after macro definitions. Here is a common programming idiom in @{m4@} for avoiding them.

@D@<undivert: Undiverting output@>

Diverted text can be undiverted explicitly using the builtin undivert:

Builtin: @{undivert ([diversions@^D(133)])@}
@$@<m4_undivert@>@Z@M@{@#Mundivert@}

Undiverts the numeric diversions given by the arguments, in the order given. If no arguments are supplied, all diversions are undiverted, in numerical order.

As a GNU extension, diversions may contain non-numeric strings, which are treated as the names of files to copy into the output without expansion. A warning is issued if a file could not be opened.

@D@<divnum: Diversion numbers@>

The current diversion is tracked by the builtin divnum:

Builtin: @{divnum@}
@$@<m4_divnum@>@Z@M@{@#Mdivnum@}

Expands to the number of the current diversion.

@D@<cleardivert: Discarding diverted text@>

Clearing selected diversions can be done with the following macro:

Composite: @{cleardivert ([diversions@^D(133)])@}

@$@<m4_cleardivert@>@Z@M@{@#Mcleardivert@}

Discard the contents of each of the listed numeric diversions.

@C@<Macros for text handling@>

@D@<len: Calculating length of strings@>

The length of a string can be calculated by @{len@}:

Builtin: @{len (string)@}
@$@<m4_len@>@(@1@)@Z@M@{@#Mlen(@1)@}

Expands to the length of string, as a decimal number.

@D@<index: Searching for substrings@>

Searching for substrings is done with @{index@}:

Builtin: @{index (string, substring)@}
@$@<m4_index@>@(@1@)@Z@M@{@#Mindex(@1)@}

Expands to the index of the first occurrence of substring in string. The first character in string has index 0. If substring does not occur in string, @{index@} expands to @{-1@}.

@D@<regexp: Searching for regular expressions@>

Searching for regular expressions is done with the builtin regexp:

Builtin: @{regexp (string, regexp, [replacement])@}
@$@<m4_regexp@>@(@1@)@Z@M@{@#Mregexp(@1)@}

Searches for regexp in string. The syntax for regular expressions is the same as in GNU Emacs, which is similar to BRE, Basic Regular Expressions in POSIX. See Syntax of Regular Expressions in the GNU Emacs Manual. Support for ERE, Extended Regular Expressions is not available, but will be added in GNU M4 2.0.

If replacement is omitted, regexp expands to the index of the first match of regexp in string. If regexp does not match anywhere in string, it expands to -1.

If replacement is supplied, and there was a match, regexp changes the expansion to this argument, with @{\n@} substituted by the text matched by the nth parenthesized sub-expression of regexp, up to nine sub-expressions. The escape @{\&@} is replaced by the text of the entire regular expression matched. For all other characters, @{\@} treats the next character literally.
A warning is issued if there were fewer sub-expressions than the @{\n@} requested, or if there is a trailing @{\@}. If there was no match, regexp expands to the empty string.

@D@<substr: Extracting substrings@>

Substrings are extracted with @{substr@}:

Builtin: @{substr (string, from, [length])@}
@$@<m4_substr@>@(@1@)@Z@M@{@#Msubstr(@1)@}

Expands to the substring of string, which starts at index from, and extends for length characters, or to the end of string, if length is omitted. The starting index of a string is always 0. The expansion is empty if there is an error parsing from or length, if from is beyond the end of string, or if length is negative.

@D@<translit: Translating characters@>

Character translation is done with translit:

Builtin: @{translit (string, chars, [replacement])@}
@$@<m4_translit@>@(@1@)@Z@M@{@#Mtranslit(@1)@}

Expands to string, with each character that occurs in chars translated into the character from replacement with the same index.

If replacement is shorter than chars, the excess characters of chars are deleted from the expansion; if chars is shorter, the excess characters in replacement are silently ignored. If replacement is omitted, all characters in string that are present in chars are deleted from the expansion. If a character appears more than once in chars, only the first instance is used in making the translation. Only a single translation pass is made, even if characters in replacement also appear in chars.

As a GNU extension, both chars and replacement can contain character-ranges, e.g., @{a-z@} (meaning all lowercase letters) or @{0-9@} (meaning all digits). To include a dash @{-@} in chars or replacement, place it first or last in the entire string, or as the last character of a range. Back-to-back ranges can share a common endpoint.
It is not an error for the last character in the range to be @{larger@} than the first. In that case, the range runs backwards, i.e., @{9-0@} means the string @{9876543210@}. The expansion of a range is dependent on the underlying encoding of characters, so using ranges is not always portable between machines.

@D@<Substituting text by regular expression@>

@E@<patsubst@>
Global substitution in a string is done by patsubst:

Builtin: @{patsubst (string, regexp, [replacement])@}
@$@<m4_patsubst@>@(@1@)@Z@M@{@#Mpatsubst(@1)@}

Searches string for matches of regexp, and substitutes replacement for each match. The syntax for regular expressions is the same as in GNU Emacs (see Regexp).

The parts of string that are not covered by any match of regexp are copied to the expansion. Whenever a match is found, the search proceeds from the end of the match, so a character from string will never be substituted twice. If regexp matches a string of zero length, the start position for the search is incremented, to avoid infinite loops.

When a replacement is to be made, replacement is inserted into the expansion, with @{\n@} substituted by the text matched by the nth parenthesized sub-expression of patsubst, for up to nine sub-expressions. The escape @{\&@} is replaced by the text of the entire regular expression matched. For all other characters, @{\@} treats the next character literally. A warning is issued if there were fewer sub-expressions than the @{\n@} requested, or if there is a trailing @{\@}.

The replacement argument can be omitted, in which case the text matched by regexp is deleted.

@E@<upcase, downcase, capitalize@>

Here is a slightly more realistic example, which capitalizes individual words or whole sentences, by substituting calls of the macros upcase and downcase into the strings.

Composite: @{upcase (text)@}
@$@<m4_upcase@>@(@1@)@Z@M@{@#Mupcase(@1)@}
Composite: @{downcase (text)@}
@$@<m4_downcase@>@(@1@)@Z@M@{@#Mdowncase(@1)@}
Composite: @{capitalize (text)@}
@$@<m4_capitalize@>@(@1@)@Z@M@{@#Mcapitalize(@1)@}

Expand to text, but with capitalization changed: @{upcase@} changes all letters to upper case, @{downcase@} changes all letters to lower case, and @{capitalize@} changes the first character of each word to upper case and the remaining characters to lower case.

@$@<Define m4_casechange@>@{@-
# @#Mupcase(text)
# @#Mdowncase(text)
# @#Mcapitalize(text)
#   change case of text, simple version
@#Mdefine(`@#Mupcase', `@#Mtranslit(`$*', `a-z', `A-Z')')
@#Mdefine(`@#Mdowncase', `@#Mtranslit(`$*', `A-Z', `a-z')')
@#Mdefine(`_@#Mcapitalize',
    `@#Mregexp(`$1', `^\(\w\)\(\w*\)',
        `@#Mupcase(`\1')`'@#Mdowncase(`\2')')')
@#Mdefine(`@#Mcapitalize', `@#Mpatsubst(`$1', `\w+', `_@#M$0(`\&')')')@}

@D@<format: Formatting strings (printf-like)@>

Formatted output can be made with format:

Builtin: @{format (format-string, @^D(133))@}
@$@<m4_format@>@(@1@)@Z@M@{@#Mformat(@1)@}

Works much like the C function @{printf@}. The first argument format-string can contain @{%@} specifications which are satisfied by additional arguments, and the expansion of format is the formatted string.

@C@<Macros for doing arithmetic@>

@D@<incr, decr: Decrement and increment operators@>

Increment and decrement of integers are supported using the builtins @{incr@} and @{decr@}:

Builtin: @{incr (number)@}
@$@<m4_incr@>@(@1@)@Z@M@{@#Mincr(@1)@}
Builtin: @{decr (number)@}
@$@<m4_decr@>@(@1@)@Z@M@{@#Mdecr(@1)@}

Expand to the numerical value of number, incremented or decremented, respectively, by one. Except for the empty string, the expansion is empty if number could not be parsed.

@D@<eval: Evaluating integer expressions@>

Integer expressions are evaluated with @{eval@}:

Builtin: @{eval (expression, [radix = 10])@}
@$@<m4_eval@>@(@1@)@Z@M@{@#Meval(@1)@}

Expands to the value of expression. The expansion is empty if a problem is encountered while parsing the arguments. If specified, radix and width control the format of the output.

Calculations are done with 32-bit signed numbers. Overflow silently results in wraparound. A warning is issued if division by zero is attempted, or if expression could not be parsed.

Expressions can contain the following operators, listed in order of decreasing precedence.

@{()@}
Parentheses

@{+ - ~ !@}
Unary plus and minus, and bitwise and logical negation

@{**@}
Exponentiation

@{* / %@}
Multiplication, division, and modulo

@{+ -@}
Addition and subtraction

@{<< >>@}
Shift left or right

@{> >= < <=@}
Relational operators

@{== !=@}
Equality operators

@{&@}
Bitwise and

@{^@}
Bitwise exclusive-or

@{|@}
Bitwise or

@{&&@}
Logical and

@{||@}
Logical or

@C@<Macros for running shell commands@>

@D@<Determining the platform@>

Sometimes it is desirable for an input file to know which platform m4 is running on. GNU @{m4@} provides several macros that are predefined to expand to the empty string; checking for their existence will confirm platform details.

Optional builtins:
@{__gnu__@}
@{__os2__@}
@{os2@}
@{__unix__@}
@{unix@}
@{__windows__@}
@{windows@}

Each of these macros is conditionally defined as needed to describe the environment of m4. If defined, each macro expands to the empty string. For now, these macros silently ignore all arguments, but in a future release of M4, they might warn if arguments are present.

(No FW definitions here...)

@D@<syscmd: Executing simple commands@>

Any shell command can be executed, using syscmd:

Builtin: @{syscmd (shell-command)@}
@$@<m4_syscmd@>@(@1@)@Z@M@{@#Msyscmd(@1)@}

Executes shell-command as a shell command.

The expansion of syscmd is void, not the output from shell-command! Output or error messages from shell-command are not read by m4. See Esyscmd, if you need to process the command output.

Prior to executing the command, m4 flushes its buffers. The default standard input, output and error of shell-command are the same as those of m4.

@D@<esyscmd: Reading the output of commands@>

If you want m4 to read the output of a shell command, use @{esyscmd@}:

Builtin: @{esyscmd (shell-command)@}
@$@<m4_esyscmd@>@(@1@)@Z@M@{@#Mesyscmd(@1)@}

Expands to the standard output of the shell command shell-command.

Prior to executing the command, m4 flushes its buffers. The default standard input and standard error of shell-command are the same as those of m4. The error output of shell-command is not a part of the expansion: it will appear along with the error output of m4.

@D@<sysval: Exit status@>

To see whether a shell command succeeded, use @{sysval@}:

Builtin: @{sysval@}
@$@<m4_sysval@>@Z@M@{@#Msysval@}

Expands to the exit status of the last shell command run with syscmd or esyscmd. Expands to 0 if no command has been run yet.

@D@<mkstemp, maketemp: Making temporary files@>

Commands specified to @{syscmd@} or @{esyscmd@} might need a temporary file, for output or for some other purpose. There is a builtin macro, @{mkstemp@}, for making a temporary file:

Builtin: @{mkstemp (template)@}
@$@<m4_mkstemp@>@(@1@)@Z@M@{@#Mmkstemp(@1)@}
Builtin: @{maketemp (template)@}
@$@<m4_maketemp@>@(@1@)@Z@M@{@#Mmaketemp(@1)@}

Expands to the quoted name of a new, empty file, made from the string template, which should end with the string @{XXXXXX@}. The six @{X@} characters are then replaced with random characters matching the regular expression @{[a-zA-Z0-9._-]@}, in order to make the file name unique.
If fewer than six @{X@} characters are found at the end of template, the result will be longer than the template. The created file will have access permissions as if by @{chmod =rw,go=@}, meaning that the current umask of the m4 process is taken into account, and at most only the current user can read and write the file.

@C@<Miscellaneous builtin macros@>

@D@<errprint: Printing error messages@>

You can print error messages using @{errprint@}:

Builtin: @{errprint (message, @^D(133))@}
@$@<m4_errprint@>@(@1@)@Z@M@{@#Merrprint(@1)@}

Prints message and the rest of the arguments to standard error, separated by spaces. Standard error is used, regardless of the @{--debugfile@} option (see Invoking m4).

@D@<m4exit: Exiting from m4@>

If you need to exit from m4 before the entire input has been read, you can use @{m4exit@}:

Builtin: @{m4exit ([code = 0])@}
@$@<m4_m4exit@>@Z@M@{@#Mm4exit@}

Causes @{m4@} to exit, with exit status code. If code is left out, the exit status is zero. If code cannot be parsed, or is outside the range of 0 to 255, the exit status is one. No further input is read, and all wrapped and diverted text is discarded.

A common use of this is to abort processing:

@E@<fatal_error@>

Composite: @{fatal_error (message)@}
@$@<m4_fatal_error@>@Z@M@{@#Mfatal_error@}

Abort processing with an error message and non-zero status. Prefix message with details about where the error occurred, and print the resulting string to standard error.

@$@<Define m4_fatal_error@>@{@-
@#Mdefine(`@#Mfatal_error',
    `@#Merrprint(@#M__program__:@#M__file__:@#M__line__`: fatal error: $*
')@#Mm4exit(`1')')@}

@D@<Printing current location@>

To make it possible to specify the location of an error, three utility builtins exist:

Builtin: __file__
Builtin: __line__
Builtin: __program__

Expand to the quoted name of the current input file, the current input line number in that file, and the quoted name of the current invocation of m4.

(No FW definitions given).

@C@<Fast loading of frozen state@>

See <A HREF="https://www.gnu.org/software/m4/manual/m4.html#Using-frozen-files">Using-frozen-files</A> from manual.

@C@<Solutions to common problems@>

See more at <A HREF="https://www.gnu.org/software/m4/manual/m4.html#Answers">M4 Answers</A>.

@D@<exch@>
The @{exch@} macro (see Arguments) as presented requires clients to double quote their arguments. A nicer definition, which lets clients follow the rule of thumb of one level of quoting per level of parentheses, involves adding quotes in the definition of exch, as follows:

@$@<m4_exch@>@(@2@)@Z@M@{@#Mexch(@1,@2)@}
@$@<Define m4_exch@>@{@#Mdefine(`exch', ``$2', `$1'')@}

@D@<Solution for forloop@>

The @{forloop@} macro (see Forloop) as presented earlier can go into an infinite loop if given an iterator that is not parsed as a macro name. It does not do any sanity checking on its numeric bounds, and only permits decimal numbers for bounds.

@E@<forloop2@>

Here is an improved version, shipped as @{m4-1.4.17/examples/forloop2.m4@}; this version also optimizes overhead by calling four macros instead of six per iteration (excluding those in text), by not dereferencing the iterator in the helper @{_forloop@}.

@$@<m4_forloop2@>@Z@M@{@#Mforloop2@}
@$@<Define m4_forloop2@>@{@-
# @#Mforloop2(var, from, to, stmt) - improved version:
#   works even if VAR is not a strict macro name
#   performs sanity check that FROM is larger than TO
#   allows complex numerical expressions in TO and FROM
@#Mdefine(`@#Mforloop2', `@#Mifelse(@#Meval(`($2) <= ($3)'), `1',
    `@#Mpushdef(`$1')_@#M$0(`$1', @#Meval(`$2'),
        @#Meval(`$3'), `$4')@#Mpopdef(`$1')')')
@#Mdefine(`_@#Mforloop2',
    `@#Mdefine(`$1', `$2')$4`'@#Mifelse(`$2', `$3', `',
        `$0(`$1', @#Mincr(`$2'), `$3', `$4')')')@}

@E@<forloop3@>

One more optimization is still possible. Instead of repeatedly assigning a variable then invoking or dereferencing it, it is possible to pass the current iterator value as a single argument. Coupled with curry if other arguments are needed (see Composition), or with helper macros if the argument is needed in more than one place in the expansion, the output can be generated with three, rather than four, macros of overhead per iteration.
Notice how the file @{m4-1.4.17/examples/forloop3.m4@} rearranges the arguments of the helper _forloop to take two arguments that are placed around the current value. By splitting a balanced set of parantheses across multiple arguments, the helper macro can now be shared by forloop and the new forloop_arg.

@$@<m4_forloop3@>@Z@M@{@#Mforloop3@}
@$@<Define m4_forloop3@>@{@-
# @#Mforloop3_arg(from, to, macro) - invoke MACRO(value) for
#   each value between FROM and TO, without define overhead
@#Mdefine(`forloop3_arg', `@#Mifelse(eval(`($1) <= ($2)'), `1',
    `_@#Mforloop3(`$1', @#Meval(`$2'), `$3(', `)')')')
# forloop3(var, from, to, stmt) - refactored to share code
@#Mdefine(`@#Mforloop3', `@#Mifelse(@#Meval(`($2) <= ($3)'), `1',
    `@#Mpushdef(`$1')_@#Mforloop3(@#Meval(`$2'), @#Meval(`$3'),
        `@#Mdefine(`$1',', `)$4')@#Mpopdef(`$1')')')
@#Mdefine(`_@#Mforloop3',
    `$3`$1'$4`'@#Mifelse(`$1', `$2', `',
        `$0(@#Mincr(`$1'), `$2', `$3', `$4')')')@}

@D@<Solution for foreach@>

The foreach and foreachq macros (see Foreach) as presented earlier each have flaws.

